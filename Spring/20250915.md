## Transactional Propagation

트랜잭션 전파란 하나의 트랜잭션이 진행 중일 때 다른 트랜잭션이 있는 메서드를 호출하면 어떻게 동작할지를 결정하는 규칙이다.

즉, A라는 작업이 트랜잭션 안에서 실행되다가 B라는 작업을 호출했을 때, B 작업을 A 작업의 트랜잭션에 포함시킬지, 아니면 B 작업만의 새로운 트랜잭션을 만들지, 또는 트랜잭션 없이 실행할지를 정의하는 것

### 전파 속성
- `Required` (기본값)
  - 기존 트랜잭션이 있으면 참여하고, 없으면 새로 생성한다.
  - `REQUIRES_NEW`
    - 항상 새로운 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 잠시 보류시킨다.
    - 외부 트랜잭션의 성공/실패와 상관없이, 현재 작업은 반드시 독립적으로 커밋/롤백되어야 할 때  (e.g. 로그 기록)
  - `NESTED`
    - 기존 트랜잭션이 있으면 그 안에 중첩된 트랜잭션을 생성한다.
    - 기존 트랜잭션의 영향을 받지만, 자신만의 독립적인 저장 지점을 가져서 부분적인 롤백이 가능하게 하고 싶을 때  사용
  - `SUPPORTS`
    - 기존 트랜잭션이 있으면 참여하고, 없으면 트랜잭션 없이 실행한다.
    - 트랜잭션이 필수는 아니지만, 있다면 같이 묶여서 처리되어야 할 때
  - `NOT_SUPPORTED`
    - 트랜잭션 없이 실행하고, 기존 트랜잭션이 있으면 잠시 보류시킨다.
    - 트랜잭션과 무관하게 실행되어야 하는 로직일 때
  - `MANDATORY`
    - 반드시 기존 트랜잭션이 있어야 하고, 없으면 예외를 발생시킨다.
    - 다른 트랜잭션의 일부로만 실행되어야 함을 강제하고 싶을 때
  - `NEVER`
    - 반드시 트랜잭션이 없어야 하고, 기존 트랜잭션이 있으면 예외를 발생시킨다.
    - 트랜잭션을 사용하면 안 되는 로직임을 명확히 하고 싶을 때

### `REQUIRES_NEW`와 `NESTED의` 근본적인 차이와 제약사항
두 속성 모두 "독립적인 실행"이라는 공통점이 있지만, 동작 방식과 그에 따른 제약이 다르다.

- 동작 원리
  - REQUIRES_NEW: 완전히 새로운 물리적 트랜잭션을 생성한다.  
    별도의 DB 커넥션을 획득하여 트랜잭션을 시작하는 것을 의미한다. (정확히는 커넥션 풀의 다른 커넥션을 사용) 외부 트랜잭션과 내부 트랜잭션은 서로 전혀 영향을 주지 않고 완전히 분리된다.
  - NESTED: 새로운 물리적 트랜잭션을 만들지 않는다. 대신, 기존 트랜잭션에 중첩된 논리적 트랜잭션을 생성하고 Savepoint를 사용한다.  
    즉, 같은 DB 커넥션 상에서 동작하며, 롤백 지점을 따로 설정하는 것이다.

- 주요 차이점 
  - 외부 트랜잭션의 롤백
    - REQUIRES_NEW: 외부 트랜잭션이 롤백되어도, 내부 REQUIRES_NEW 트랜잭션은 이미 독자적으로 커밋/롤백되었기 때문에 영향을 받지 않는다.
    - NESTED: 외부 트랜잭션이 롤백되면, NESTED로 실행된 내부 트랜잭션의 커밋 내용도 함께 롤백된다. 부모 트랜잭션에 종속적이다.

### Self-Invocation 문제
하나의 클래스 내에서 @Transactional이 붙은 메서드가 `@Transactional(propagation = Propagation.REQUIRES_NEW)`가 붙은 다른 메서드를 호출해도, 전파 속성이 무시되고 같은 트랜잭션 안에서 실행된다.

이는 `@Transactional`의 동작 원리가 AOP를 통해 프록시 객체를 생성하여 동작하기 때문이다. 
CGLIB 기반으로 프록시 객체를 생성하기 때문에 내부 메서드 호출은 `this`를 통해 메서드를 호출하여 상속 받은 프록시 객체의 메서드가 아닌 실제 객체의 메서드를 호출해서 새로운 트랜잭션이 시작될 수 없다. (전파 속성 무시)

-> `private`, `final`, `static` 메서드에는 `@Transactional`이 적용되지 않는다. 프록시가 해당 메서드를 오버라이딩 할 수 없기 때문

### 롤백(Rollback)규칙
트랜잭션의 성공/실패는 Exception 발생 여부에 따라 결정된다. 전파 속성은 이 롤백 규칙과 연관이 있다.

- 기본 롤백 정책
  - Unchecked Exception (e.g., RuntimeException, Error) 발생 시: 자동으로 롤백된다.
  - Checked Exception (e.g., IOException, SQLException) 발생 시: 자동으로 롤백되지 않고 커밋된다.

- 롤백 정책 제어 (`rollbackFor`, `noRollbackFor`)
  - `@Transactional(rollbackFor = CustomException.class)`: 특정 Checked Exception이 발생했을 때도 롤백하도록 지정할 수 있다. 
  - `@Transactional(noRollbackFor = SpecificRuntimeException.class)`: 특정 Unchecked Exception이 발생해도 롤백하지 않도록 지정할 수 있다.

- 전파 속성과의 관계 
  - REQUIRES_NEW로 호출된 내부 트랜잭션에서 예외가 발생하고 롤백되면, 이 예외가 외부 트랜잭션으로 전파될 경우 외부 트랜잭션도 롤백될 수 있다. (내부에서 try-catch로 예외를 잡아서 처리하면 외부 트랜잭션은 롤백되지 않음)
  - NESTED로 호출된 내부 트랜잭션이 롤백되어도, 외부 트랜잭션은 Savepoint 지점까지만 롤백되고 계속 진행할 수 있다.
