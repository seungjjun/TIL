## 안티패턴

### 스마트 UI 패턴
- 데이터 입출력을 UI 레벨에서 처리하는 것
- 비즈니스 로직도 UI 레벨에서 처리하는 것
- UI 레벨에서 데이터베이스에 직접 접근

흔히 서버의 3-tier layer architecture에서 컨트롤러를 UI 로 생각하고, 컨트롤러에서 DB 접근 또는, 비즈니스 로직을 처리하는 것을 스마트 UI 패턴이라고 한다.  
이 패턴은 유지보수와 확장성에 문제를 일으킬 수 있다.

이러한 이유로 스마트 UI패턴은 안티패턴이다.

### 컨트롤러의 역할
컨트롤러 같은 UI 코드는 사용자의 입출력을 받고 어떤 비즈니스 로직을 실행할지 결정하는 역할만 해야 한다.

- API 호출 방식을 정의한다.
- 어떤 비즈니스 로직을 실행할지 결정한다.
- API 호출 결과를 어떤 포맷으로 응답할지 정의한다.

### 양방향 레이어드 아키텍처
양방향 레이어드 아키텍처는 레이어드 아키텍처의 안티패턴이다.
- 레이어드 아키텍처는 상위 레이어가 하위 레이어에 의존하는 구조이다.
- 양방향 레이어드 아키텍처는 상위 레이어가 하위 레이어에 의존하고, 하위 레이어가 상위 레이어에 의존하는 구조이다.

레이어드 아키텍터가 지켜야 하는 가장 기초적인 제약은 "**레이어 간 의존 방향은 단방향을 유지해야 한다**"는 것이다.

### 코드 중복과 코드 유사성
중복은 역할과 책임, 구현 등이 비슷할 때를 보고 중복이라고 부른다.  
그래서 데이터 형태가 유사하다고 중복이라고 보기 어렵다.  
목적도 같고 해결 방법이 같을 때 중복이라고 부른다.

유사한 데이터를 여러 개 만드는 것을 두려워 하지 마라.  
몇몇 멤버 변수가 겹친다고 데이터 모델을 어정쩡하게 공유하는 것보다 역할과 책임에 따라 확실하게 모델을 구분하는 편이 낫다.

예를 들어 PostCreateRequest와 PostCreateCommand는 유사한 데이터 모델이지만, 역할과 책임이 다르기 때문에 분리하는 것이 좋다.

### 완화된 레이어드 아키텍처
컨트롤러가 레파지토리를 직접 사용하는 형태(2개 이상의 레이러를 건너뛰는 형태)는 안티패턴으로 분류 된다.

상위 레이어가 모든 하위 레이어에 접근할 수 있는 구조를 완화된 레이어드 아키텍처라고 한다.  
이런 패턴은 스마트 UI 같은 코드가 만들어지기 쉽다.  
그리고 비즈니스 로직이 들어가는곳이 애매해진다.

즉, 비즈니스 로직이 역할과 책임에 따라 유의미한 객체 한 곳으로 모이지 않고, 중구난방으로 퍼져나가게 된다.
그래서 완화된 레이어드 아키텍처는 안티패턴이다.

### 트랜잭션 스크립트
트랜잭션 스크립트는 비즈니스 레이어에 위치하는 서비스 컴포넌트에서 발생하는 안티패턴이다.
트랜잭션 스크립트는 비즈니스 로직을 단순히 트랜잭션 단위로 묶는 것을 말한다.

비즈니스 로직은 어디에 위치해야 하는가?  
-> 비즈니스 로직은 도메인 모**델에 위치**해야 한다.

서비스 컴포넌트는 **도메인을 불러와서 도메인에 일을 시키는 정도의 역할**만 해야 한다.

트랜잭션 스크립트 같은 코드가 발생하는 이유는 개발자가 '서비스는 비즈니스 로직을 처리하는 곳'이라고 생각하기 때문이다.  
그리고 객체 모델을 서비스의 비즈니스 로직을 실행하기 위한 데이터 저장 공간 수준으로 인식한다.  
그래서 트랜잭션 스크립트 같은 절차지향적인 코드가 발생한다.

--- 

### 애플리케이션의 본질은 "**도메인**"이다.
서비스는 도메인을 위한 무대일 뿐 애플리케이션의 본질은 도메인이다.  
서비스는 도메인이 협력할 무대만 제공하고 그 이상의 역할을 하지 않는게 좋다.

단순히 데이터 덩이리로 사용하는 객체를 도메인 객체로 만들고, 서비스 로직에 있는 비즈니스 로직을 도메인으로 옮기자.  
디자인 패턴이나 SOLID를 논하기 전에 능동적인 도메인을 만들고 도메인 끼리 협력하게 만들어야 한다.

**서비스는 도메인 객체나 도메인 서비스라고 불리는 도메인에 일을 위임하는 공간이어야 한다.**
