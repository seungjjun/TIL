# 예외

## 예외 종류
- Error
  - 시스템 레벨의 심각한 오류(OOM, ThreadDeath 등). 애플리케이션 코드에서 catch 하면 안된다.
- Unchecked exception
    - RuntimeException을 상속한 예외들
    - 컴파일러가 체크하지 않아 예외가 발생할 것을 미리 체크하지 못한다.
    - 주로 프로그램의 오류(NPE 등등)가 있을 떄 발생하도록 의도되었다.
- Checked exception
  - 컴파일 시점에 예외를 체크하기 때문에 예외처리를 해줘야 한다.
  - RuntimeException을 상속하지 않은 예외들
  - 복구 가능성이 있는 예외 상황에 사용

## 예외 처리 3가지 기법
### 예외 복구
- 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- e.g. 네트워크 접속 실패 시, 일정 시간 대기 후 재접속을 시도하는 로직

### 예외 회피
- 예외 처리를 자신이 담당하지 않고, 자신을 호출한 쪽으로 던져버리는 것
- 무책임하게 던지는 것은 회피가 아닌 '책임 회피'일 수 있다. (긴밀한 관계가 있는 오브젝트 사이에서만 사용)

### 예외 전환
- 예외를 그대로 던지지 않고, 적절한 예외로 변환해서 던지는 것 -> 중첩 예외
- 내부에서 발생한 로우 레벨의 예외를, 더 의미 있는 추상화된 예외로 바꿔서 던진다.
- 체크 예외를 런타임 예외로 포장하여 불필요한 try-catch를 줄인다.

### 전환 방식 중 중첩 예외  
- 중첩 예외의 목적은 단순히 다른 예외로 포장하는 것이 아닌, 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.
- 예외를 잡아서 아무런 조치를 취하지 않거나 의미 없느 throws 선언을 남발하는 것은 위험하다.
  - 체크 예외를 계속 throws를 사용해 넘기는건 무의미
- 예외를 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.
- 복구할 수 없는 에외는 가능한 한 빨리 런타임 예외로 전환하는 것이 좋다.

## 예외처리 전략
### 런타임 예외의 보편화
- 체크 예외: 일반적인 예외를 다룬다.
  - 체크 예외는 복구할 가능성이 조금이라도 있어, 자바는 이를 처리하는 catch 블록이나 throws 선언을 강제하고 있다.
  - 대응이 불가능한 체크 예외라면 런타임 예외로 전환해서 던지는게 낫다.
- 언체크 예외 -> 프로그램상의 오류를 다룬다.

### 애플리케이션 예외
- 시스템 또는 외부의 예외상황이 원인이 아닌 애플맄케이션 자체의 로직에 의해 의도적으로 발생시키거나, 반드시 catch 해서 발생하는 예외를 애플리케이션 예외라고 한다.
  - e.g. 은행 잔고에서 출금할 때 잔고를 확인하고 허용하는 범위를 넘어 출금을 요청하면 예외를 발생시키는 상황

## 예외 전환
- 예외 전환의 목적
  - 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것
  - 로우레벨의 예외를 좀 더 의미있고 추상화된 예외로 바꿔서 던져주는 것

- 스프링의 JdbcTemplate이 던지는 DataAccessException은 런타임 예외로 SQLException을 포장해주는 역할을 한다.
  - 대부분 복구가 불가능한 예외인 SQLException에 대해 애플레키에션 레벨에서는 신경 쓰지 않도록 해주는 것.

### DAO 인터페이스와 구현의 분리
- DAO는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서 사용한다.
- DAO를 사용하는 쪽에서 DAO 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경 쓰지 않아도 된다.
- DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고 DI를 통해 제공되도록 해야 한다.
