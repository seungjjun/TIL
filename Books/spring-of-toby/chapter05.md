# 서비스 추상화

## 트랜잭션 서비스 추상화

### 트랜잭션 경계 설정
- 사용자 레벨 업그레이드 작업 도중 에러가 발생하면, 앞선 2명의 등급이 올라간 상태로 남으면 안 된다.
  - 원자성 위배
- 트랜잭션의 원자성: 작업은 모두 성공하거나, 아예 아무것도 안 한 상태여야 함
- JDBC 트랜잭션의 한계로 비즈니스 로직 안에서 트랜잭션을 시작하려면 Connection 객체를 직접 다뤄야 한다
  - 이는 데이터 액세스 기술이 비즈니스 로직에 침투하게 만든다.
- 트랜잭션 동기화
  - 스프링의 `TransactionSynchronizationManager`를 사용하여 Connection을 파라미터로 넘기지 않고도 트랜잭션을 유지할 수 있게 한다.
  - 하지만 여전히 JDBC 기술에 의존적인 코드가 남아있다.
- 글로벌 트랜잭션
  - 하나의 DB가 아니라 여러 DB를 사용하는 상황에서 트랜잭션이 필요하면 JTA(Java Transaction API)를 써야한다.
  - JDBC를 사용하는 로직에서 JTA 로직으로 바꾸려면 이를 사용하는 코드를 전부 수정해야 하는 문제가 발생 

### 트랜잭션 추상화
- 스프링은 트랜잭션 기술의 공통점을 뽑아 `PlatformTransactionManager` 인터페이스로 추상화함.
- UserService는 구체적인 기술(JDBC, Hibernate 등)을 알 필요 없이 추상화된 인터페이스(PlatformTransactionManager)에만 의존한다.
- 어떤 구현체를 쓸지 DI만 해주면 된다.
- 추상화를 도입하면 실제 구현체 대신 테스트용 대역(Mock, Stub)을 사용하기 쉬워져, 고립된 단위 테스트가 가능해진다.

### 비즈니스 로직의 격리
- 비즈니스 로직은 데이터 액세스 기술, 트랜잭션 기술(TransactionManager), 외부 서비스 등의 구체적인 기술 구현 내용으로부터 독립적이어야 한다.
- 비즈니스 로직과 트랜잭션 관리라는 서로 다른 관심사를 분리하고, 적절한 추상화를 도입함으로써 코드는 깔끔해지고 변경에 용이

## 테스트 대역
### 테스트 스텁
- 테스트 대상에게 테스트에 필요한 정보를 제공해준다.
- e.g. MockUserDao 처럼 특정 사용자 목록을 리턴하여 비즈니스 로직에 문제 없도록

### 목 오브젝트
- 스텁의 기능에 더해, 행위를 검증하는 역할을 한다.
- 테스트 대상이 올바르게 협력 오브젝트를 호출했는지 확인
- e.g. 메일 발송 메소드가 정확히 2번 호출되었는지? 
