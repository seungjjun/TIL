## 자바와 객체 지향

### 객체 지향은 인간 지향이다.
- 우주 만물은 객체들의 합이다.  
- 현실세계를 인지하는 방식으로 프로그램을 만드는 방식이 객체 지향이다. 
  - 즉, 객체 지향은 직관적이다.
- 세상에 존재하는 모든 것은 사물, 즉 객체(object)다.
- 각각의 사물은 고유하다.
- 사물은 속성을 갖는다.
- 사물은 행위를 한다.

### 객체 지향의 4대 특성
- 캡슐화: 정보 은닉
- 상속: 재사용
  - 상속을 표현할 떄 `inheritance` 단어가 아닌 `extends` 를 사용하자
- 추상화: 모델링
- 다형성: 사용 편의

### 추상화: 모델링
- `추상`이란 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용이다.
- 추상화는 모델링이다.
- 추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션 경계)에 대한 특성만 가지고 재조합하는 것이다.
  - 애플리케이션 경계란 만들고자 하는 애플리케이션이 어디에서 사용될지를 생각하는 것
  - 애플리케이션 경계에 따라 클래스 설계가 달라진다. (만들고자 하는 애플리케이션에서 필요 없는 특성들을 제거)
- 모델은 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다.
  - **모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것**

### 클래스 멤버 vs 객체 멤버
- 클래스 멤버는 static 키워드와 함꼐 사용되고 T 메모리의 스태틱 영역에 상주한다.
  - 즉, 클래스 멤버는 static(정적) 멤버라고도 한다.
- 객체 멤버들은 객체가 클래스의 인스턴스이므로 인스턴스 멤버라고도 한다.
- 클래스 멤버 = static 멤버 = 정적 멤버
- 객체 멤버 = 인스턴스 멤버

### 상속: 재사용 + 확장
- 상속은 재사용과 확장으로 이해해야 한다.
  - 부모와 자식간의 관계로 이해하지 말자.
- 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.
  - 상속을 부모 - 자식 클래스라는 표현보다는 상위 - 하위 클래스 또는 슈퍼 - 서브 클래스로 표현하자.
- 상속 관계에서 반드시 `하위 클래스는 상위 클래스다.`라는 문장을 만족해야 한다.
  - 객체 지향 설계 5원칙 중 LSP(리스코프 치환) 원칙을 나타내는 말이다.
- 자바 언어에서 `inheritance(상속)` 라는 키워드는 존재하지 않고, `extends(확장)`가 존재한다.
- 하위 클래스의 인스턴스를 생성하면 힙 영역에 하위 클래스의 인스턴스 뿐만 아니라 상위 클래스의 인스턴스도 힙 영역에 생긴다. (최상위 클래스인 Object 클래스의 인스턴스도 함께 생성된다.)

### 다중 상속
- 자바에서는 다중 상속을 지원하지 않는다.
  - 다이아몬드 문제로 인해 자바는 다중 상속을 지원하지 않는다.
- 대신 인터페이스를 도입하여 다중 상속의 득을 취하고 실을 버렸다.

### 인터페이스
- 인터페이스는 `구현 클래스 is able to 인터페이스` 관계이다.
- 상속은 하위 클래스에게 특성을 상속해주고 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제한다.
- 상위 클래스는 물려줄 특성이 풍부할 수록 좋고, 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다.
  - 상위 클래스가 풍부할 수록 좋은 이유는 LSP 에 따른 이유이다.
  - 인터페이스에 메서드가 적을수록 좋은 이유는 ISP(인터페이스 분할 원칙)에 따른 이유이다.

### 다형성: 사용편의성
- 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
- 오버라이딩을 통한 메서드 재정의, 오버로딩을 통한 메서드 중복 정의를 통해 다형성엘 제공한다.

### 캡슐화: 정보 은닉
- 자바에서 정보 은닉은 접근 제어자를 사용하여 객체에 접근을 제어하여 정보를 숨기는 것이다.
- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 `클래스명.정적멤버` 형식으로 접근하는 것을 권장한다.

### Call By Value와 Call By Reference
- 기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 해석
- 객체 참조 변수는 저장하고 있는 값을 주소로 해석
- Call By Value에 의해 변수를 복사하든 Call By Reference에 의해 참조 변수를 복사하든 결국은 변수가 가진 값이 그대로 복사된다.
  - 값을 값 자체로 해석하는지, 주소값으로 해석하는지의 차이다.
- Call By Value와 Call By Reference를 다르다고 이해하기 보다는 기본 자료형 변수는 저장하는 값을 값 자체로 판단하고, 참조 변수는 저장하고 있는 값을 주소로 판단한다고 이해하는 것이 더 쉽다.
