## Double-Checked Locking, DCL

싱글톤 패턴의 이중 확인 잠금(Double-Checked Locking, DCL)은 **스레드에 안전**하면서도 **지연 초기화**를 구현할 때 발생하는 성능 저하를 줄이기 위한 최적화 기법이다.

### Singleton
싱글톤은 인스턴스가 오직 하나만 존재하도록 보장하는 패턴이다.  
이 인스턴스는 필요할 때까지 생성하지 않는 '지연 초기화' 방식이 자주 사용된다.

가장 일반적인 싱글톤 패턴 구현 코드이다.
```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

위 싱글톤 코드는 멀티스레드 환경에서 문제가 발생할 수 있다.  

멀티스레드 환경에서 스레드 A와 스레드 B가 동시에 `instance == null` 을 통과하면,
두 스레드 모두 `instance = new Singleton();` 코드를 실행하여 인스턴스가 2개 생성될 수 있어 싱글톤 원칙이 깨진다.

이 문제를 해결하기 위해 `synchronized` 키워드를 사용하여 해결할 수 있다.
```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    // 메소드 전체에 synchronized 키워드 사용
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

문제점: 이 방법은 스레드 안전성을 보장하지만, 성능 저하를 유발한다.

인스턴스를 생성하는 초기 1회를 제외하고, 이미 인스턴스가 생성된 후 (`instance != null`) 에도 모든 스레드는 getInstance()를 호출할 때마다 불필요한 락 경쟁을 벌여야 한다.

### Double-Checked Locking(DCL)
DCL은 스레드 안전, 성능 저하 문제를 모두 해결할 수 있다.

락 없이 확인하고 인스턴스가 없으면 락을 걸고, 이후 다시 확인하는 방법이 이중 확인의 핵심이다.

DCL을 구현하는 코드는 다음과 같다.

```java
public class Singleton {
    // volatile 키워드 적용
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### volatile 키워드의 필요성
DCL을 올바르게 구현하려면 인스턴스 변수에 `volatile` 키워드를 붙여야 한다.  
만일 volatile이 없으면 DCL은 깨질 수 있다.

#### 명령어 재배치
`instance = new Singleton();` 코드는 한 줄이지만 내부적으로 여러단계에 걸쳐 동작한다.
1. Singleton 객체를 위한 메모리 공간을 할당한다.
2. Singleton의 생성자를 호출하여 객체를 초기화한다.
3. 할당된 메모리 주소를 instance 변수에 대입한다.

컴퓨터는 성능 최적화를 위해 이 명령어 순서를 바꿀 수 있다. (e.g. 1 → 3 → 2)

이러한 이유로 volatile 키워드가 없으면 명령어 재배치로 인해 문제가 발생할 수 있다.

1. 스레드 A가 동기화 블록에 진입해 instance = new Singleton()을 실행한다.
2. 명령어 재배치가 발생하여, (1)메모리 할당 후 (3) instance 변수 대입이 먼저 일어난다. (아직 (2)생성자 호출은 안 됨)
3. 이때 instance는 null이 아니지만, 완전히 초기화되지 않은 객체를 가리킨다.
4. 스레드 B가 getInstance()를 호출한다.
5. 스레드 B는 instance가 null이 아니라고 판단한다. (스레드 A가 3번을 실행했으므로)
6. 스레드 B는 동기화 블록을 건너뛰고, 아직 초기화가 덜 끝난 instance를 반환받는다.
7. 스레드 B가 이 객체를 사용하려 하면 오류(NPE 등)가 발생한다.

위와 같은 문제를 방지하기 위해 volatile은 명령어 재배치를 금지한다.  
volatile 변수에 대한 쓰기는 해당 변수 이전에 일어난 모든 쓰기 작업이 완료된 후에만 수행되도록 보장한다.

#### 메모리 가시성
한 스레드가 volatile 변수의 값을 변경하면, 이 변경 사항이 즉시 다른 모든 스레드에게 보이도록 보장한다.

### 정리
**생성할 때: synchronized (상호 배제)**
- synchronized 키워드로 한 스레드만 인스턴스를 생성할 수 있도록 보장

**읽을 때: volatile (가시성 + 재배치 방지)**
- 메모리 가시성
  - 한 스레드가 인스턴스를 생성하면 volatile 키워드에 의해 즉시 다른 스레드의 메모리에 반영
- 명령어 재배치 방지
  - 객체를 초기화 하고 해당 객체의 메모리 주소를 변수에 대입하는 것을 보장

즉, DCL의 핵심은 volatile 키워드로 **가시성**과 **재배치 방지**를 보장하여 '읽기' 성능을 높이고, synchronized 키워드로 '생성' 시에만 동기화하여 **스레드 안전성을 확보**하는 것이다.