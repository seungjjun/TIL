## enum

`enum`은 Java 5 버전에서 처음 도입되었다. 그전까지 상수들을 정의하기 위해 다음과 같은 방법을 주로 사용했다.

### **정수 상수 패턴**

가장 흔한 방식은 `static final int` 변수를 사용하여 상수 그룹을 정의하는 것이었다.

```java
public class DayBeforeEnum {
    public static final int SUNDAY = 0;
    public static final int MONDAY = 1;
    public static final int TUESDAY = 2;
    // ...
}
```

이 방식은 간단했지만 몇 가지 치명적인 문제점이 있었다

- **타입 안전성 문제**: `DayBeforeEnum.SUNDAY`는 그저 정수 `0`일 뿐이다. 요일을 인자로 받는 메서드에 `DayBeforeEnum.MONDAY` 대신 숫자 `1`을 넣거나, 심지어 전혀 관련 없는 정수 값(예: `100`)을 넣어도 컴파일러는 아무런 문제가 없다고 판단한다. 이는 런타임에 예기치 않은 오류를 발생시킬 수 있는 문제 요소였다.
- **의미의 모호성**: 정수 값 자체는 아무런 의미를 담고 있지 않다. 디버깅 시 변수에 `0`이라는 값이 들어있을 때, 이것이 `SUNDAY`를 의미하는지 아니면 다른 어떤 상태를 의미하는지 즉시 파악하기 어렵다.
- **확장성의 한계**: 만약 다른 클래스에서도 요일과 관련된 상수를 정의하고 그 값이 우연히 겹친다면 (예: `OrderStatus.PENDING = 0`), 두 상수는 완전히 다른 의미임에도 불구하고 `==` 비교 시 `true`를 반환하는 문제가 발생할 수 있다.

### **문자열 상수 패턴**

정수 상수의 단점을 보완하기 위해 문자열을 사용하기도 했다.

```java
public class DayStringPattern {
    public static final String SUNDAY = "SUNDAY";
    public static final String MONDAY = "MONDAY";
}
```

이 방식은 디버깅 시 의미를 파악하기 쉽다는 장점이 있었지만, 정수 상수 패턴과 다른 문제를 발생시켰다.

- **성능 저하**: 문자열 비교는 `equals()` 메서드를 사용해야 하므로 정수 비교(`==`)보다 느리다.
- **오타 발생 가능성**: `"SUNDAY"` 대신 `"sunday"`나 `"SUNDAYY"`와 같이 오타가 포함된 문자열을 사용해도 컴파일 시점에서는 오류를 발견할 수 없다.

이러한 문제들을 근본적으로 해결하고, **타입에 안전하면서도 의미가 명확한 상수를 정의**하기 위해 `enum`이 탄생했다.

---

### `enum`의 본질: 특별한 형태의 클래스

자바의 `enum`은 단순한 상수의 나열이 아니라, 사실상 **특별한 종류의 클래스**이다. `enum`을 선언하면 컴파일러는 이를 `java.lang.Enum` 클래스를 상속받는 클래스로 변환한다.

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY
}
```

위의 `Day` `enum`은 내부적으로 다음과 유사한 클래스로 취급된다.

```java
public final class Day extends java.lang.Enum<Day> {
    public static final Day SUNDAY = new Day("SUNDAY", 0);
    public static final Day MONDAY = new Day("MONDAY", 1);
    // ...

    private Day(String name, int ordinal) {
        super(name, ordinal);
    }

    public static Day[] values() { /* ... */ }
    public static Day valueOf(String name) { /* ... */ }
}
```

`enum`의 각 상수(`SUNDAY`, `MONDAY` 등)는 `public static final`로 선언된 `Day` 클래스의 **인스턴스(객체)이**다. 이 객체들은 `enum`이 로드될 때 단 한 번만 생성되므로, **Singleton** 패턴의 한 형태로 볼 수 있다.

`enum`은 다음과 같은 특징을 갖게 된다.

- **타입 안전성**: `Day` 타입의 변수에는 `Day` 열거형의 인스턴스(`Day.SUNDAY`, `Day.MONDAY` 등)만 할당할 수 있다. 다른 타입의 값은 컴파일 오류를 발생시킨다.
- **네임스페이스**: `Day.SUNDAY`와 같이 `enum` 타입의 이름이 붙기 때문에 코드의 의미가 명확해진다.
- **임의의 메서드 및 필드 추가 가능**: `enum`은 클래스이므로, 생성자, 필드, 메서드를 추가하여 각 상수와 관련된 데이터를 캡슐화하고 특정 동작을 정의할 수 있다.

```java
public enum Day {
    SUNDAY("일요일"), MONDAY("월요일"); // ...

    private final String koreanName;

    Day(String koreanName) { // 생성자는 private만 가능
        this.koreanName = koreanName;
    }

    public String getKoreanName() {
        return koreanName;
    }
}
```

---

### `enum`의 장점과 단점

### **장점**

1. **코드 가독성 및 명확성**: `if (day == Day.SUNDAY)`와 같이 코드가 훨씬 직관적이고 이해하기 쉬워진다. 매직 넘버나 문자열을 코드에서 제거할 수 있다.
2. **컴파일 시점 타입 안전성**: 정해진 상수 외의 값을 사용하려는 시도를 컴파일러가 막아주어 버그 발생 가능성을 크게 줄인다.
3. **싱글턴 보장**: `enum`의 각 상수는 JVM 내에서 유일한 인스턴스임이 보장된다. 따라서 `==` 연산자로 안전하게 비교할 수 있으며, `equals()`보다 성능상 이점이 있다.

### **단점**

1. **메모리 사용량**: `enum`의 각 상수는 객체이므로, 정수 상수에 비해 더 많은 메모리를 차지한다. `enum`이 로드될 때 모든 상수 인스턴스가 생성되어 메모리에 할당되어 있는다. 따라서 수천 개의 상수가 필요한 경우 메모리 부담이 될 수 있다.
2. **성능 이슈**: `enum`을 초기화하는 과정에서 약간의 시간 소요가 발생할 수 있다. 하지만 이는 애플리케이션 시작 시 한 번뿐이며, 대부분의 경우 성능에 미치는 영향은 무시할 수 있는 수준이다.
3. **상속 불가**: `enum`은 `java.lang.Enum`을 이미 상속받고 있으므로 다른 클래스를 상속할 수 없다. (인터페이스 구현은 가능)

---

### 메모리 관점에서 본 `enum`

`enum` 상수는 일반 객체처럼 **힙 영역**에 저장된다.

또한, `enum` 타입 자체에 대한 정보(메타데이터)와 `static final`로 선언된 상수 인스턴스에 대한 참조는 **메서드 영역** 또는 **메타스페이스**에 저장된다.

`enum`이 처음 사용될 때 클래스 로더에 의해 로드되며, 이때 모든 상수 인스턴스가 생성되어 힙에 할당된다. 이후로는 이 생성된 인스턴스들이 계속 재사용한다.

예를 들어 `Day` `enum`에는 `SUNDAY`부터 `SATURDAY`까지 7개의 인스턴스가 생성된다. 만약 `Day` `enum`이 수천 개의 상수를 가지고 있다면, 그 수만큼의 객체가 애플리케이션 실행 내내 힙 메모리를 차지하게 된다.

따라서 메모리가 극도로 제한적인 상황에서는 많은 수의 상수를 `enum`으로 정의하는 것을 피해야 할 수도 있다.

하지만 대부분의 서버 및 웹 애플리케이션 환경에서 `enum`이 야기하는 메모리 부담은 그로 인해 얻는 **타입 안전성과 코드 명확성이라는 이점에 비하면 미미한 수준**이다. 성능보다는 안정성과 유지보수성이 더 중요한 시스템 개발에서 `enum`은 필수적이다.

### 결론

결론적으로, `enum`은 과거의 무분별한 상수 사용으로 발생했던 타입 불안정성과 코드의 모호함을 해결하기 위해 탄생한, **타입 안전성이 보장되는 객체지향적 상수**이다.

약간의 메모리를 사용하여 코드의 안정성과 가독성, 유지보수성을 극적으로 향상시켜주는 매우 강력하고 유용한 자바의 핵심 기능이라고 할 수 있다.
