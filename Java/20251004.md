## Java Map
자바의 Map은 Key와 Value를 한 쌍으로 묶어 저장하는 자료구조이다.

Key를 통해 O(1)의 속도로 값을 빠르게 찾는 특징이 있다.

## 동작 원리: 해싱 (Hashing)
HashMap을 포함한 대부분의 Map 구현체는 해싱을 기반으로 동작하여 평균 O(1)의 성능을 제공한다.

### 내부 동작 순서 (put(key, value) 기준)
- 해시코드 생성: key 객체의 hashCode() 메서드를 호출하여 고유한 정수 값인 해시코드를 얻는다.
- 인덱스 계산: 이 해시코드를 Map 내부의 해시 함수로 한 번 더 가공한 뒤, 내부 배열의 크기로 나눈 나머지를 구해 데이터가 저장될 배열 인덱스를 결정한다.
- 데이터 저장: 계산된 인덱스가 가리키는 위치에 (key, value) 쌍을 담은 Node 객체를 저장한다.

### 내부 구조 배열과 노드
- Map은 내부적으로 key값을 Node[] 배열으로 데이터를 관리한다. 
- 이 배열의 각 칸을 버킷(bucket)이라고 부른다. 
- 배열의 각 버킷에는 실제 데이터 쌍 (key, value)과 다음 노드를 가리키는 포인터(next) 등을 담고 있는 Node 객체가 저장된다.

### 해시 충돌
- 서로 다른 키가 우연히 해시 값이 같아 같은 버킷에 저장되는 경우를 해시 충돌이라고 한다.
- Map은 해시 충돌 문제를 분리 연결볍으로 해결한다.
  - 분리 연결법: 충돌이 발생한 버킷에 들어온 Node를 LinkedList 자료구조를 이용해 연결하여 충돌을 해결한다.
  - Java 8부터 분리 연결법에서 연결된 리스트의 길이가 일정 기준을 넘어가면 성능 향상을 위해 레드-블랙 트리 구조로 변경하여 데이터를 저장한다.

## HashMap, LinkedHashMap, TreeMap
- HashMap
  - 내부 구조: 해시 테이블 (배열 + 연결 리스트/트리)
  - 순서: 보장하지 않음. 키의 해시값에 따라 저장 위치가 결정되므로 입력 순서와 무관하다.
  - 성능: 추가, 삭제, 검색 모두 평균 O(1). 가장 빠른 성능을 보인다.
  - 용도: 순서가 중요하지 않고, 가장 빠른 데이터 접근이 필요할 때 사용하는 **가장 일반적인 Map**
- LinkedHashMap (입력 순서를 기억)
  - 내부 구조: 해시 테이블 + 양방향 연결 리스트(Doubly Linked List)
  - 순서: 입력된 순서(insertion-order)를 그대로 유지한다. 각 Node가 데이터 저장과 별개로 before, after 포인터를 통해 전체적으로 연결되어 있다.
  - 성능: HashMap과 동일하게 평균 O(1)이다. 순서 유지를 위한 약간의 메모리 오버헤드가 있다.
  - 용도: HashMap의 빠른 성능을 유지하면서 데이터의 입력 순서가 중요할 때 사용한다.
- TreeMap (항상 정렬 상태를 유지)
  - 내부 구조: 레드-블랙 트리 (Red-Black Tree), 자가 균형 이진 탐색 트리이다.
  - 순서: 키(Key)를 기준으로 항상 자동 정렬된다. (키 객체의 Comparable 또는 생성 시 제공된 Comparator 기준)
  - 성능: 추가, 삭제, 검색 모두 O(logN)을 보장한다. HashMap보다는 느리지만 데이터 양이 많아져도 안정적인 성능을 제공한다.
  - 용도: 키를 정렬된 상태로 유지해야 하거나, 특정 범위의 데이터를 검색해야 할 때 매우 유용하다.
